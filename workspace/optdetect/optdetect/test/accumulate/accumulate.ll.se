Printing analysis 'Scalar Evolution Analysis' for function 'free_array_2d':
Classifying expressions for: @free_array_2d
  %nrows.addr = alloca i64, align 8
  -->  %nrows.addr
  %arr.addr = alloca i8**, align 8
  -->  %arr.addr
  %i = alloca i32, align 4
  -->  %i
  %0 = load i32* %i, align 4
  -->  %0		Exits: <<Unknown>>
  %conv = sext i32 %0 to i64
  -->  (sext i32 %0 to i64)		Exits: <<Unknown>>
  %1 = load i64* %nrows.addr, align 8
  -->  %1		Exits: <<Unknown>>
  %2 = load i32* %i, align 4
  -->  %2		Exits: <<Unknown>>
  %idxprom = sext i32 %2 to i64
  -->  (sext i32 %2 to i64)		Exits: <<Unknown>>
  %3 = load i8*** %arr.addr, align 8
  -->  %3		Exits: <<Unknown>>
  %arrayidx = getelementptr inbounds i8** %3, i64 %idxprom
  -->  ((8 * (sext i32 %2 to i64))<nsw> + %3)<nsw>		Exits: <<Unknown>>
  %4 = load i8** %arrayidx, align 8
  -->  %4		Exits: <<Unknown>>
  %5 = load i32* %i, align 4
  -->  %5		Exits: <<Unknown>>
  %inc = add nsw i32 %5, 1
  -->  (1 + %5)		Exits: <<Unknown>>
  %6 = load i8*** %arr.addr, align 8
  -->  %6
  %7 = bitcast i8** %6 to i8*
  -->  %6
Determining loop execution counts for: @free_array_2d
Loop %for.cond: Unpredictable backedge-taken count. 
Loop %for.cond: Unpredictable max backedge-taken count. 
Printing analysis 'Scalar Evolution Analysis' for function 'create_array_2d':
Classifying expressions for: @create_array_2d
  %nrows.addr = alloca i64, align 8
  -->  %nrows.addr
  %ncols.addr = alloca i64, align 8
  -->  %ncols.addr
  %init.addr = alloca i8, align 1
  -->  %init.addr
  %foo = alloca i8**, align 8
  -->  %foo
  %i = alloca i32, align 4
  -->  %i
  %j = alloca i32, align 4
  -->  %j
  %0 = load i64* %nrows.addr, align 8
  -->  %0
  %mul = mul i64 8, %0
  -->  (8 * %0)
  %call = call noalias i8* @malloc(i64 %mul) #3
  -->  %call
  %1 = bitcast i8* %call to i8**
  -->  %call
  %2 = load i32* %i, align 4
  -->  %2		Exits: <<Unknown>>
  %conv = sext i32 %2 to i64
  -->  (sext i32 %2 to i64)		Exits: <<Unknown>>
  %3 = load i64* %nrows.addr, align 8
  -->  %3		Exits: <<Unknown>>
  %4 = load i64* %ncols.addr, align 8
  -->  %4		Exits: <<Unknown>>
  %mul2 = mul i64 1, %4
  -->  %4		Exits: <<Unknown>>
  %call3 = call noalias i8* @malloc(i64 %mul2) #3
  -->  %call3		Exits: <<Unknown>>
  %5 = load i32* %i, align 4
  -->  %5		Exits: <<Unknown>>
  %idxprom = sext i32 %5 to i64
  -->  (sext i32 %5 to i64)		Exits: <<Unknown>>
  %6 = load i8*** %foo, align 8
  -->  %6		Exits: <<Unknown>>
  %arrayidx = getelementptr inbounds i8** %6, i64 %idxprom
  -->  ((8 * (sext i32 %5 to i64))<nsw> + %6)<nsw>		Exits: <<Unknown>>
  %7 = load i32* %j, align 4
  -->  %7		Exits: <<Unknown>>
  %conv5 = sext i32 %7 to i64
  -->  (sext i32 %7 to i64)		Exits: <<Unknown>>
  %8 = load i64* %ncols.addr, align 8
  -->  %8		Exits: <<Unknown>>
  %9 = load i8* %init.addr, align 1
  -->  %9		Exits: <<Unknown>>
  %10 = load i32* %j, align 4
  -->  %10		Exits: <<Unknown>>
  %idxprom9 = sext i32 %10 to i64
  -->  (sext i32 %10 to i64)		Exits: <<Unknown>>
  %11 = load i32* %i, align 4
  -->  %11		Exits: <<Unknown>>
  %idxprom10 = sext i32 %11 to i64
  -->  (sext i32 %11 to i64)		Exits: <<Unknown>>
  %12 = load i8*** %foo, align 8
  -->  %12		Exits: <<Unknown>>
  %arrayidx11 = getelementptr inbounds i8** %12, i64 %idxprom10
  -->  ((8 * (sext i32 %11 to i64))<nsw> + %12)<nsw>		Exits: <<Unknown>>
  %13 = load i8** %arrayidx11, align 8
  -->  %13		Exits: <<Unknown>>
  %arrayidx12 = getelementptr inbounds i8* %13, i64 %idxprom9
  -->  ((sext i32 %10 to i64) + %13)<nsw>		Exits: <<Unknown>>
  %14 = load i32* %j, align 4
  -->  %14		Exits: <<Unknown>>
  %inc = add nsw i32 %14, 1
  -->  (1 + %14)		Exits: <<Unknown>>
  %15 = load i32* %i, align 4
  -->  %15		Exits: <<Unknown>>
  %inc14 = add nsw i32 %15, 1
  -->  (1 + %15)		Exits: <<Unknown>>
  %16 = load i8*** %foo, align 8
  -->  %16
Determining loop execution counts for: @create_array_2d
Loop %for.cond4: Unpredictable backedge-taken count. 
Loop %for.cond4: Unpredictable max backedge-taken count. 
Loop %for.cond: Unpredictable backedge-taken count. 
Loop %for.cond: Unpredictable max backedge-taken count. 
Printing analysis 'Scalar Evolution Analysis' for function 'accumulate_1d_addr':
Classifying expressions for: @accumulate_1d_addr
  %in.addr = alloca i8*, align 8
  -->  %in.addr
  %out.addr = alloca i8*, align 8
  -->  %out.addr
  %y.addr = alloca i32, align 4
  -->  %y.addr
  %x.addr = alloca i32, align 4
  -->  %x.addr
  %rowstride.addr = alloca i64, align 8
  -->  %rowstride.addr
  %s.addr = alloca i32, align 4
  -->  %s.addr
  %w_size.addr = alloca i64, align 8
  -->  %w_size.addr
  %w_size_half = alloca i64, align 8
  -->  %w_size_half
  %acc = alloca i8, align 1
  -->  %acc
  %j = alloca i32, align 4
  -->  %j
  %i = alloca i32, align 4
  -->  %i
  %0 = load i64* %w_size.addr, align 8
  -->  %0
  %div = udiv i64 %0, 2
  -->  (%0 /u 2)
  %1 = load i64* %w_size_half, align 8
  -->  %1
  %sub = sub i64 0, %1
  -->  (-1 * %1)
  %conv = trunc i64 %sub to i32
  -->  (trunc i64 (-1 * %1) to i32)
  %2 = load i32* %j, align 4
  -->  %2		Exits: <<Unknown>>
  %conv1 = sext i32 %2 to i64
  -->  (sext i32 %2 to i64)		Exits: <<Unknown>>
  %3 = load i64* %w_size_half, align 8
  -->  %3		Exits: <<Unknown>>
  %4 = load i64* %w_size_half, align 8
  -->  %4		Exits: <<Unknown>>
  %sub3 = sub i64 0, %4
  -->  (-1 * %4)		Exits: <<Unknown>>
  %conv4 = trunc i64 %sub3 to i32
  -->  (trunc i64 (-1 * %4) to i32)		Exits: <<Unknown>>
  %5 = load i32* %i, align 4
  -->  %5		Exits: <<Unknown>>
  %conv6 = sext i32 %5 to i64
  -->  (sext i32 %5 to i64)		Exits: <<Unknown>>
  %6 = load i64* %w_size_half, align 8
  -->  %6		Exits: <<Unknown>>
  %7 = load i32* %x.addr, align 4
  -->  %7		Exits: <<Unknown>>
  %8 = load i32* %j, align 4
  -->  %8		Exits: <<Unknown>>
  %sub10 = sub nsw i32 %7, %8
  -->  ((-1 * %8) + %7)		Exits: <<Unknown>>
  %conv11 = sext i32 %sub10 to i64
  -->  (sext i32 ((-1 * %8) + %7) to i64)		Exits: <<Unknown>>
  %9 = load i64* %rowstride.addr, align 8
  -->  %9		Exits: <<Unknown>>
  %mul = mul i64 %conv11, %9
  -->  ((sext i32 ((-1 * %8) + %7) to i64) * %9)		Exits: <<Unknown>>
  %10 = load i32* %y.addr, align 4
  -->  %10		Exits: <<Unknown>>
  %conv12 = sext i32 %10 to i64
  -->  (sext i32 %10 to i64)		Exits: <<Unknown>>
  %add = add i64 %mul, %conv12
  -->  ((sext i32 %10 to i64) + ((sext i32 ((-1 * %8) + %7) to i64) * %9))		Exits: <<Unknown>>
  %11 = load i32* %i, align 4
  -->  %11		Exits: <<Unknown>>
  %conv13 = sext i32 %11 to i64
  -->  (sext i32 %11 to i64)		Exits: <<Unknown>>
  %sub14 = sub i64 %add, %conv13
  -->  ((sext i32 %10 to i64) + (-1 * (sext i32 %11 to i64)) + ((sext i32 ((-1 * %8) + %7) to i64) * %9))		Exits: <<Unknown>>
  %12 = load i8** %in.addr, align 8
  -->  %12		Exits: <<Unknown>>
  %arrayidx = getelementptr inbounds i8* %12, i64 %sub14
  -->  ((sext i32 %10 to i64) + (-1 * (sext i32 %11 to i64)) + ((sext i32 ((-1 * %8) + %7) to i64) * %9) + %12)		Exits: <<Unknown>>
  %13 = load i8* %arrayidx, align 1
  -->  %13		Exits: <<Unknown>>
  %conv15 = zext i8 %13 to i32
  -->  (zext i8 %13 to i32)		Exits: <<Unknown>>
  %14 = load i8* %acc, align 1
  -->  %14		Exits: <<Unknown>>
  %conv16 = zext i8 %14 to i32
  -->  (zext i8 %14 to i32)		Exits: <<Unknown>>
  %add17 = add nsw i32 %conv16, %conv15
  -->  ((zext i8 %13 to i32) + (zext i8 %14 to i32))		Exits: <<Unknown>>
  %conv18 = trunc i32 %add17 to i8
  -->  (%13 + %14)		Exits: <<Unknown>>
  %15 = load i32* %i, align 4
  -->  %15		Exits: <<Unknown>>
  %inc = add nsw i32 %15, 1
  -->  (1 + %15)		Exits: <<Unknown>>
  %16 = load i32* %j, align 4
  -->  %16		Exits: <<Unknown>>
  %inc20 = add nsw i32 %16, 1
  -->  (1 + %16)		Exits: <<Unknown>>
  %17 = load i8* %acc, align 1
  -->  %17
  %18 = load i32* %x.addr, align 4
  -->  %18
  %conv22 = sext i32 %18 to i64
  -->  (sext i32 %18 to i64)
  %19 = load i64* %rowstride.addr, align 8
  -->  %19
  %mul23 = mul i64 %conv22, %19
  -->  ((sext i32 %18 to i64) * %19)
  %20 = load i32* %y.addr, align 4
  -->  %20
  %conv24 = sext i32 %20 to i64
  -->  (sext i32 %20 to i64)
  %add25 = add i64 %mul23, %conv24
  -->  ((sext i32 %20 to i64) + ((sext i32 %18 to i64) * %19))
  %21 = load i8** %out.addr, align 8
  -->  %21
  %arrayidx26 = getelementptr inbounds i8* %21, i64 %add25
  -->  ((sext i32 %20 to i64) + ((sext i32 %18 to i64) * %19) + %21)
Determining loop execution counts for: @accumulate_1d_addr
Loop %for.cond5: Unpredictable backedge-taken count. 
Loop %for.cond5: Unpredictable max backedge-taken count. 
Loop %for.cond: Unpredictable backedge-taken count. 
Loop %for.cond: Unpredictable max backedge-taken count. 
Printing analysis 'Scalar Evolution Analysis' for function 'accumulate_2d_addr':
Classifying expressions for: @accumulate_2d_addr
  %in.addr = alloca i8**, align 8
  -->  %in.addr
  %out.addr = alloca i8**, align 8
  -->  %out.addr
  %y.addr = alloca i32, align 4
  -->  %y.addr
  %x.addr = alloca i32, align 4
  -->  %x.addr
  %w_size.addr = alloca i64, align 8
  -->  %w_size.addr
  %w_size_half = alloca i32, align 4
  -->  %w_size_half
  %acc = alloca i8, align 1
  -->  %acc
  %j = alloca i32, align 4
  -->  %j
  %i = alloca i32, align 4
  -->  %i
  %0 = load i64* %w_size.addr, align 8
  -->  %0
  %div = udiv i64 %0, 2
  -->  (%0 /u 2)
  %conv = trunc i64 %div to i32
  -->  (trunc i64 (%0 /u 2) to i32)
  %1 = load i32* %w_size_half, align 4
  -->  %1
  %sub = sub nsw i32 0, %1
  -->  (-1 * %1)
  %2 = load i32* %j, align 4
  -->  %2		Exits: <<Unknown>>
  %3 = load i32* %w_size_half, align 4
  -->  %3		Exits: <<Unknown>>
  %4 = load i32* %w_size_half, align 4
  -->  %4		Exits: <<Unknown>>
  %sub2 = sub nsw i32 0, %4
  -->  (-1 * %4)		Exits: <<Unknown>>
  %5 = load i32* %i, align 4
  -->  %5		Exits: <<Unknown>>
  %6 = load i32* %w_size_half, align 4
  -->  %6		Exits: <<Unknown>>
  %7 = load i32* %x.addr, align 4
  -->  %7		Exits: <<Unknown>>
  %8 = load i32* %i, align 4
  -->  %8		Exits: <<Unknown>>
  %add = add nsw i32 %7, %8
  -->  (%8 + %7)		Exits: <<Unknown>>
  %idxprom = sext i32 %add to i64
  -->  (sext i32 (%8 + %7) to i64)		Exits: <<Unknown>>
  %9 = load i32* %y.addr, align 4
  -->  %9		Exits: <<Unknown>>
  %10 = load i32* %j, align 4
  -->  %10		Exits: <<Unknown>>
  %add7 = add nsw i32 %9, %10
  -->  (%10 + %9)		Exits: <<Unknown>>
  %idxprom8 = sext i32 %add7 to i64
  -->  (sext i32 (%10 + %9) to i64)		Exits: <<Unknown>>
  %11 = load i8*** %in.addr, align 8
  -->  %11		Exits: <<Unknown>>
  %arrayidx = getelementptr inbounds i8** %11, i64 %idxprom8
  -->  ((8 * (sext i32 (%10 + %9) to i64))<nsw> + %11)<nsw>		Exits: <<Unknown>>
  %12 = load i8** %arrayidx, align 8
  -->  %12		Exits: <<Unknown>>
  %arrayidx9 = getelementptr inbounds i8* %12, i64 %idxprom
  -->  ((sext i32 (%8 + %7) to i64) + %12)<nsw>		Exits: <<Unknown>>
  %13 = load i8* %arrayidx9, align 1
  -->  %13		Exits: <<Unknown>>
  %conv10 = zext i8 %13 to i32
  -->  (zext i8 %13 to i32)		Exits: <<Unknown>>
  %14 = load i8* %acc, align 1
  -->  %14		Exits: <<Unknown>>
  %conv11 = zext i8 %14 to i32
  -->  (zext i8 %14 to i32)		Exits: <<Unknown>>
  %add12 = add nsw i32 %conv11, %conv10
  -->  ((zext i8 %13 to i32) + (zext i8 %14 to i32))		Exits: <<Unknown>>
  %conv13 = trunc i32 %add12 to i8
  -->  (%13 + %14)		Exits: <<Unknown>>
  %15 = load i32* %i, align 4
  -->  %15		Exits: <<Unknown>>
  %inc = add nsw i32 %15, 1
  -->  (1 + %15)		Exits: <<Unknown>>
  %16 = load i32* %j, align 4
  -->  %16		Exits: <<Unknown>>
  %inc15 = add nsw i32 %16, 1
  -->  (1 + %16)		Exits: <<Unknown>>
  %17 = load i8* %acc, align 1
  -->  %17
  %18 = load i32* %x.addr, align 4
  -->  %18
  %idxprom17 = sext i32 %18 to i64
  -->  (sext i32 %18 to i64)
  %19 = load i32* %y.addr, align 4
  -->  %19
  %idxprom18 = sext i32 %19 to i64
  -->  (sext i32 %19 to i64)
  %20 = load i8*** %out.addr, align 8
  -->  %20
  %arrayidx19 = getelementptr inbounds i8** %20, i64 %idxprom18
  -->  ((8 * (sext i32 %19 to i64))<nsw> + %20)<nsw>
  %21 = load i8** %arrayidx19, align 8
  -->  %21
  %arrayidx20 = getelementptr inbounds i8* %21, i64 %idxprom17
  -->  ((sext i32 %18 to i64) + %21)<nsw>
Determining loop execution counts for: @accumulate_2d_addr
Loop %for.cond3: Unpredictable backedge-taken count. 
Loop %for.cond3: Unpredictable max backedge-taken count. 
Loop %for.cond: Unpredictable backedge-taken count. 
Loop %for.cond: Unpredictable max backedge-taken count. 
Printing analysis 'Scalar Evolution Analysis' for function 'main':
Classifying expressions for: @main
  %retval = alloca i32, align 4
  -->  %retval
  %argc.addr = alloca i32, align 4
  -->  %argc.addr
  %argv.addr = alloca i8**, align 8
  -->  %argv.addr
  %nrows = alloca i64, align 8
  -->  %nrows
  %ncols = alloca i64, align 8
  -->  %ncols
  %foo = alloca i8**, align 8
  -->  %foo
  %bar = alloca i8**, align 8
  -->  %bar
  %call = call i8** @create_array_2d(i64 5, i64 5, i8 zeroext 1)
  -->  %call
  %call1 = call i8** @create_array_2d(i64 5, i64 5, i8 zeroext 1)
  -->  %call1
  %0 = load i8*** %foo, align 8
  -->  %0
  %1 = load i8*** %bar, align 8
  -->  %1
  %2 = load i8*** %bar, align 8
  -->  %2
  %arrayidx = getelementptr inbounds i8** %2, i64 1
  -->  (8 + %2)<nsw>
  %3 = load i8** %arrayidx, align 8
  -->  %3
  %arrayidx2 = getelementptr inbounds i8* %3, i64 1
  -->  (1 + %3)<nsw>
  %4 = load i8* %arrayidx2, align 1
  -->  %4
  %conv = zext i8 %4 to i32
  -->  (zext i8 %4 to i32)
  %call3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([9 x i8]* @.str, i32 0, i32 0), i32 %conv)
  -->  %call3
  %5 = load i8*** %foo, align 8
  -->  %5
  %6 = load i8*** %bar, align 8
  -->  %6
Determining loop execution counts for: @main
