Accelerating the execution of software is an important task, either from an economical point of view (e.g. energy costs, hardware utilization), because runtime is a fundamental requirement (e.g. real-time computing), or because data-sets are so huge, that they cannot be handled in reasonable time any more. For this purpose, hardware accelerators like GPUs and FPGAs are more and more used in general purpose computing as an additional resource.
\\

Applications can benefit from the use of hardware accelerators. They manage the use of accelerators and even require the presence of a certain accelerator type. This behaviour might be undesired, either because the computing resource is unavailable or blocked, or because there is an additional resource from which the application could benefit more, in terms of performance and energy-efficiency. Thus migrating software tasks, or at least parts of it, between different accelerator types is a desired feature for computing in heterogeneous environments.
\\

Migrating binary programs on-the-fly between heterogeneous computing resource is still challenging. This holds in particular for non instruction-based architectures such as FPGAs
%\cite{cite:6913232}. 
A special challenge in this area is the avoidance of synthesis overhead. Mapping and synthesizing binary applications to an equivalent FPGA implementation still takes a disproportional amount of time. As a consequence, tasks have to run longer to amortize these costs.
\\

One approach to address this issue is to use domain specific overlay-architectures. An overlay is an FPGA configuration, which implements a set of predefined, usually coarse-grained elements, which are themselves reconfigurable. Their granularity can vary from networks of fine grained operations like adders and multipliers %\cite{SynthFreeJIT:5771273}
, to vector-processors
%\cite{ARC2014b} 
or even many-core 
%\cite{MARC:5695273}
architectures. An overlay is considered as domain specific, if it is customized for a certain application domain. As an example, one can think of a generic convolution filter with a configurable filter matrix. One major advantage of such architectures is that they can typically be reprogrammed much faster compared to re-synthesizing a complete FPGA-design. On the other hand, a single overlay might be too specific for a wide range of tasks. For this reason, there is no "one overlay fits all"-solution, but one has to choose from many overlays, depending on the application and its parameters. This, together with the overlay configuration, is a manual process.
